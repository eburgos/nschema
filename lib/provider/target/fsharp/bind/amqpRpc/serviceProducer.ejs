namespace {{= namespace }}

open Newtonsoft.Json
open Newtonsoft.Json.Converters
open System.Runtime.Serialization
open RabbitMQ.Client
open RabbitMQ.Client.MessagePatterns

type {{= name }}AMQPChannel (channel: IModel) =
    let replyQueueName = channel.QueueDeclare().QueueName
    let consumer = new QueueingBasicConsumer (channel)
    do
        channel.BasicConsume (replyQueueName, true, consumer) |> ignore
    let rec replyLoop (consumer: QueueingBasicConsumer) correlationId =
        let ea = consumer.Queue.Dequeue()
        match ea.BasicProperties.CorrelationId with
        | cId when cId = correlationId ->
            ea
        | _ ->
            replyLoop consumer correlationId
    static member serializeJson o =
        let sb = new System.Text.StringBuilder()
        use textWriter = new System.IO.StringWriter(sb)
        use writer = new Newtonsoft.Json.JsonTextWriter(textWriter)
        let serializer = new Newtonsoft.Json.JsonSerializer()
        serializer.Serialize(writer, o)
        do
            writer.Flush()
        sb.ToString()
    member this.PostMessage (queueName: string) (message: byte[]) =
        channel.BasicPublish(System.String.Empty, queueName, null, message)
    member this.PostJsonMessage (queue: string) (message: 'a) =
        message
        |> {{= name }}AMQPChannel.serializeJson
        |> System.Text.Encoding.UTF8.GetBytes
        |> this.PostMessage (queue)
    member this.RPCCall (queueName: string) (headers: System.Collections.Generic.IDictionary<string, obj>) (message: byte[]) =
        let props = channel.CreateBasicProperties()
        let correlationId = System.Guid.NewGuid().ToString()
        props.Headers <- headers
        props.ContentType <- "application/json"
        props.ReplyTo <- replyQueueName
        props.CorrelationId <- correlationId
        channel.BasicPublish (queueName, queueName, props, message)
        let response = replyLoop consumer correlationId
        response.Body
    member this.RPCJsonCall (queue: string) (message: 'a) (headers: System.Collections.Generic.IDictionary<string, obj>)  =
        message
        |> {{= name }}AMQPChannel.serializeJson
        |> System.Text.Encoding.UTF8.GetBytes
        |> this.RPCCall queue headers
        |> System.Text.Encoding.UTF8.GetString
    interface System.IDisposable with
        member this.Dispose () =
            channel.Dispose()
            ()

type public {{= name }}AMQPEndpoint(uri) = //"amqp://guest:guest@localhost/"
    let factory = new ConnectionFactory(Uri = uri)
    let connection = factory.CreateConnection()
    member this.GetChannel () =
        let channel = connection.CreateModel()
        new {{= name }}AMQPChannel(channel)
    interface System.IDisposable with
        member this.Dispose () =
            connection.Dispose()
            ()

type {{= name }}(connectionString: string, queueName: string) =
    let amqpEndpoint = new {{= name }}AMQPEndpoint ( connectionString )
    let amqpEndpointChannel = amqpEndpoint.GetChannel()
{{ include ./arraySplit }}
    {{ for(var op in operations) {
    var $inMessage = operations[op].inMessage;
    var $outMessage = operations[op].outMessage;
    var $nschemaMessage,
    $nschemaMessageDirection;
    }}/// <summary>{{- operations[op].description || '' }}</summary>
{{ $inMessage.data.forEach(function (par) {
}}    /// <param name="{{- par.name }}">{{- par.description || '' }}</param>
{{ }); }}    /// <returns>{{- $outMessage.data.map(function (d) { return d.description || ''; }).join(', ') }}</returns>
    member this.{{= op }}{{ $inMessage.data.forEach(function (par) {
}} ({{= par.name }}: {{= $fsharp.typeName(par.type, $nschema) }}){{ }); }} : ({{ $nschemaMessage = $outMessage; $nschemaMessageDirection = 'out'; }}{{ include messageType }}) =
        let paramDict = dict [|("x-operationName","{{= op }}" :> obj)|]
        let msg = [{{- $inMessage.data.map(function (par) { return par.name + ' |> ' + name + 'AMQPChannel.serializeJson '; }).join(';') }}]
                  |> String.concat ","
        let outputStrList =
            "[" + msg + "]"
            |> System.Text.Encoding.UTF8.GetBytes
            |> amqpEndpointChannel.RPCCall queueName paramDict
            |> System.Text.Encoding.UTF8.GetString
            |> arraySplit
{{ $outMessage.data.forEach(function (outputPar, outputParIndex) {}}
        let {{- outputPar.name }} =
            use textReader = new System.IO.StringReader (outputStrList.[{{- outputParIndex }}])
            let reader = new JsonTextReader (textReader)
            serializer.Deserialize<{{= $fsharp.typeName(outputPar.type, $nschema) }}>(reader){{});}}
        ({{- $outMessage.data.map(function (d) { return d.name; }).join(', ') }})
    {{ } }}
    interface System.IDisposable with
        member this.Dispose () =
            (amqpEndpoint :> System.IDisposable).Dispose ()
            (amqpEndpointChannel :> System.IDisposable).Dispose ()
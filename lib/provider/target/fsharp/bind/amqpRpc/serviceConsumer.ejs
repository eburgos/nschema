namespace {{= namespace }}

open Newtonsoft.Json
open Newtonsoft.Json.Converters
open System.Runtime.Serialization

/// <summary>{{ if (typeof(description) === 'string') { }}{{= description }}{{ } }}</summary>
[<AbstractClass>]
type {{= name }}Consumer(connectionString: string, queueName: string) as self =
    let connectionFactory = new RabbitMQ.Client.ConnectionFactory (Uri = connectionString)
    let connection = connectionFactory.CreateConnection ()
    let serializer = new JsonSerializer ()
    let channel = connection.CreateModel ()
    let arraySplit (strOriginal: string) =
        let str = strOriginal.Replace("\r\n", "").Replace("\n", "").Replace("\r", "")

        use textReader = new System.IO.StringReader (str)
        let reader = new JsonTextReader (textReader)

        let rec tokenSplit (reader: JsonTextReader) acc startLine startIdx: string list =
            reader.Read() |> ignore
            match reader.Depth, reader.TokenType with
            | _, JsonToken.None ->
                acc
            | 0, JsonToken.StartArray ->
                tokenSplit reader acc reader.LineNumber reader.LinePosition
            | 1, JsonToken.StartObject | 1, JsonToken.StartArray ->
                tokenSplit reader acc reader.LineNumber (reader.LinePosition - 1)
            | 1, JsonToken.EndObject | 1, JsonToken.EndArray ->
                let newValue = str.Substring(startIdx, reader.LinePosition - startIdx)
                tokenSplit reader (newValue::acc) reader.LineNumber (reader.LinePosition + 1)
            | 1, JsonToken.String ->
                let newValue = "\"" + (reader.Value |> string) + "\""
                tokenSplit reader (newValue::acc) reader.LineNumber (reader.LinePosition + 1)
            | 1, JsonToken.Boolean ->
                let newValue = (reader.Value |> string).ToLower()
                tokenSplit reader (newValue::acc) reader.LineNumber (reader.LinePosition + 1)
            | 1, JsonToken.Undefined ->
                let newValue = "undefined"
                tokenSplit reader (newValue::acc) reader.LineNumber (reader.LinePosition + 1)
            | 1, JsonToken.Null ->
                let newValue = "null"
                tokenSplit reader (newValue::acc) reader.LineNumber (reader.LinePosition + 1)
            | 1, _ ->
                let newValue = (reader.Value |> string)
                tokenSplit reader (newValue::acc) reader.LineNumber (reader.LinePosition + 1)
            | _, _ ->
                tokenSplit reader acc startLine startIdx
        tokenSplit reader [] 0 0
        |> List.rev
    let messageHandler (channel: RabbitMQ.Client.IModel) (consumer) (eventArgs: RabbitMQ.Client.Events.BasicDeliverEventArgs) =
        let body = eventArgs.Body
        let props = eventArgs.BasicProperties
        use connection = connectionFactory.CreateConnection ()
        use channel = connection.CreateModel ()
        let replyProps = channel.CreateBasicProperties ()
        replyProps.CorrelationId <- props.CorrelationId
        try
            let parameters =
                body
                |> System.Text.Encoding.UTF8.GetString
                |> arraySplit
                |> Array.ofSeq
            let response =
                match eventArgs.BasicProperties.Headers.["x-operationName"] |> string with
{{ for(var op in operations) {
    var $inMessage = operations[op].inMessage;
    var $outMessage = operations[op].outMessage;
    var $nschemaMessage,
    $nschemaMessageDirection,
    $paramCount = 0,
    $currentParam,
    $paramsString;
}}                  | "{{= op }}" ->
{{ $inMessage.data.forEach(function (p) {
   $paramCount += 1; $currentParam = 'parameter' + $paramCount; }}
                    let {{= $currentParam }} =
                        use textReader = new System.IO.StringReader (parameters.[{{= $paramCount - 1 }}])
                        let reader = new JsonTextReader (textReader)
                        serializer.Deserialize<{{= $fsharp.typeName(p.type, $nschema) }}>(reader)
{{ }); }}
                    let {{ $paramCount = 0; $paramsString = $outMessage.data.map(function (p) { $paramCount += 1; $currentParam = 'response' + $paramCount; return $currentParam; }).join(','); }}{{= $paramsString }} = (self.{{= op }} {{ $paramCount = 0; $paramsString = $inMessage.data.map(function (p) { $paramCount += 1; $currentParam = 'parameter' + $paramCount; return ' ( ' + $currentParam + ' ) '; }).join(' '); }}{{= $paramsString }} )
                    let value =
                        [{{ $paramCount = 0; $paramsString = $outMessage.data.map(function (p) { $paramCount += 1; $currentParam = 'response' + $paramCount; return $currentParam; }).join(','); }}{{= $paramsString }}]
                        |> Seq.map (fun r ->
                                        use textWriter = new System.IO.StringWriter ()
                                        let writer = new JsonTextWriter(textWriter)
                                        serializer.Serialize(writer, r)
                                        textWriter.ToString()
                                    )
                        |> String.concat ","
                    "[" + value + "]"

{{ } }}
                  | opName ->
                        channel.BasicNack(eventArgs.DeliveryTag, false, false)
                        failwith "Unsupported operation: " + opName
            let responseBytes = System.Text.Encoding.UTF8.GetBytes(response)
            channel.BasicPublish ("", props.ReplyTo, replyProps, responseBytes)
            channel.BasicAck(eventArgs.DeliveryTag, false)
        with
            | e ->
                channel.BasicNack (eventArgs.DeliveryTag, false, true)

    let rec consumeLoop channel (consumer: RabbitMQ.Client.QueueingBasicConsumer) queueName callback =
        try
            let eventArgs = consumer.Queue.Dequeue()
            async {
                callback channel consumer eventArgs
            }
            |> Async.Start
            // Crear un task o un thread whatever
            consumeLoop channel consumer queueName callback
        with
            | :? System.IO.EndOfStreamException ->
                ()
    let startConsume (channel) (queueName) (callback) =
        let consumer = new RabbitMQ.Client.QueueingBasicConsumer (channel)
        channel.BasicConsume (queueName, true, consumer) |> ignore
        consumeLoop channel consumer queueName callback
    do
        channel.ExchangeDeclare (queueName, RabbitMQ.Client.ExchangeType.Headers, true)
        channel.QueueDeclare (queueName, false, false, true, null) |> ignore
        channel.QueueBind (queueName, queueName, System.String.Empty, null)
        channel.BasicQos (0u, uint16(1), false)
        startConsume channel queueName messageHandler

    let disposables = [channel :> System.IDisposable;connection :> System.IDisposable]

{{ for(var op in operations) {
var $inMessage = operations[op].inMessage;
var $outMessage = operations[op].outMessage;
var $nschemaMessage,
    $nschemaMessageDirection;
}}    /// <summary>{{- operations[op].description || '' }}</summary>
{{ $inMessage.data.forEach(function (par) {
}}    /// <param name="{{- par.name }}">{{- par.description || '' }}</param>
{{ }); }}    /// <returns>{{- $outMessage.data.map(function (d) { return d.description || ''; }).join(', ') }}</returns>
    abstract member {{= op }}: {{ $nschemaMessage = $inMessage; $nschemaMessageDirection = 'in'; }}{{ include messageType }} -> ({{ $nschemaMessage = $outMessage; $nschemaMessageDirection = 'out'; }}{{ include messageType }})
{{ } }}
    interface System.IDisposable with
        member this.Dispose () =
            disposables
            |> Seq.iter (fun d -> d.Dispose () )
namespace {{= namespace }}

open Newtonsoft.Json
open Newtonsoft.Json.Converters
open System.Runtime.Serialization
open RabbitMQ.Client
open RabbitMQ.Client.MessagePatterns

type {{= name }}AMQPChannel (channel: IModel) =
    static member serializeJson o =
        let sb = new System.Text.StringBuilder()
        use textWriter = new System.IO.StringWriter(sb)
        use writer = new Newtonsoft.Json.JsonTextWriter(textWriter)
        let serializer = Newtonsoft.Json.JsonSerializer.Create()
        serializer.Serialize(writer, o)
        do
            writer.Flush()
        sb.ToString()
    member this.PostMessage (queueName: string) (message: byte[]) =
        channel.BasicPublish(System.String.Empty, queueName, null, message)
    member this.PostJsonMessage (queue: string) (message: 'a) =
        message
        |> {{= name }}AMQPChannel.serializeJson
        |> System.Text.Encoding.UTF8.GetBytes
        |> this.PostMessage (queue)
    member this.RPCCall (queueName: string) (headers: System.Collections.Generic.IDictionary<string, obj>) (message: byte[]) =
        let rpcClient = new SimpleRpcClient(channel, queueName, TimeoutMilliseconds = 500)
        do
            rpcClient.TimedOut.Add (fun _ -> ())
            rpcClient.Disconnected.Add (fun _ -> ())
        let props = channel.CreateBasicProperties()
        props.Headers <- headers
        rpcClient.Call(props, message).Body
    member this.RPCJsonCall (queue: string) (message: 'a) (headers: System.Collections.Generic.IDictionary<string, obj>)  =
        message
        |> {{= name }}AMQPChannel.serializeJson
        |> System.Text.Encoding.UTF8.GetBytes
        |> this.RPCCall queue headers
        |> System.Text.Encoding.UTF8.GetString
    interface System.IDisposable with
        member this.Dispose () =
            channel.Dispose()
            ()

type public {{= name }}AMQPEndpoint(uri) = //"amqp://guest:guest@localhost/"
    let factory = new ConnectionFactory(Uri = uri)
    let connection = factory.CreateConnection()
    member this.GetChannel () =
        let channel = connection.CreateModel()
        new {{= name }}AMQPChannel(channel)
    interface System.IDisposable with
        member this.Dispose () =
            connection.Dispose()
            ()

type {{= name }}(connectionString: string, queueName: string) =
    let amqpEndpoint = new {{= name }}AMQPEndpoint ( connectionString )
    let amqpEndpointChannel = amqpEndpoint.GetChannel()
    {{ for(var op in operations) {
    var $inMessage = operations[op].inMessage;
    var $outMessage = operations[op].outMessage;
    var $nschemaMessage,
    $nschemaMessageDirection;
    }}/// <summary>{{- operations[op].description || '' }}</summary>
{{ $inMessage.data.forEach(function (par) {
}}    /// <param name="{{- par.name }}">{{- par.description || '' }}</param>
{{ }); }}    /// <returns>{{- $outMessage.data.map(function (d) { return d.description || ''; }).join(', ') }}</returns>
    member this.{{= op }}{{ $inMessage.data.forEach(function (par) {
}} ({{= par.name }}: {{= $fsharp.typeName(par.type, $nschema) }}){{ }); }} : ({{ $nschemaMessage = $outMessage; $nschemaMessageDirection = 'out'; }}{{ include messageType }}) =
        let dict = new System.Collections.Generic.Dictionary<string, string>()
        do
            dict.["x-operationName"] <- "Authenticate"
        let msg = [{{- $inMessage.data.map(function (par) { return par.name + ' |> ' + name + 'AMQPChannel.serializeJson '; }).join(';') }}]
                  |> String.concat ","
        "[" + msg + "]"
        |> System.Text.Encoding.UTF8.GetBytes
        |> amqpEndpointChannel.RPCCall queueName dict
    {{ } }}
    interface System.IDisposable with
        member this.Dispose () =
            (amqpEndpoint :> System.IDisposable).Dispose ()
            (amqpEndpointChannel :> System.IDisposable).Dispose ()
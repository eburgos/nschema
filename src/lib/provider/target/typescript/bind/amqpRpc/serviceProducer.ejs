namespace <%= namespace %>

open Newtonsoft.Json
open Newtonsoft.Json.Converters
open System.Runtime.Serialization
open RabbitMQ.Client
open RabbitMQ.Client.MessagePatterns

type private <%= name %>AMQPChannel (channel: IModel) =
    let replyQueueName = channel.QueueDeclare("", false, false, true, new System.Collections.Generic.Dictionary<string, obj>()).QueueName
    let consumer = new QueueingBasicConsumer (channel)
    do
        channel.BasicConsume (replyQueueName, true, consumer) |> ignore
    let rec replyLoop (consumer: QueueingBasicConsumer) correlationId =
        let ea = consumer.Queue.Dequeue()
        match ea.BasicProperties.CorrelationId with
        | cId when cId = correlationId ->
            ea
        | _ ->
            replyLoop consumer correlationId
    static member serializeJson o =
        let sb = new System.Text.StringBuilder()
        use textWriter = new System.IO.StringWriter(sb)
        use writer = new Newtonsoft.Json.JsonTextWriter(textWriter)
        let serializer = new Newtonsoft.Json.JsonSerializer()
        serializer.Serialize(writer, o)
        do
            writer.Flush()
        sb.ToString()
    member this.DeclareQueue (queueName: string) =
        channel.QueueDeclare(queueName, true, false, false, null)
    member this.DeclareExchange (exchangeName: string) =
        channel.ExchangeDeclare(exchangeName, ExchangeType.Direct, true, false, new System.Collections.Generic.Dictionary<string, obj>())
    member this.PostMessage (queueName: string) (message: byte[]) =
        channel.BasicPublish(System.String.Empty, queueName, null, message)
    member this.PostJsonMessage (queue: string) (message: 'a) =
        message
        |> <%= name %>AMQPChannel.serializeJson
        |> System.Text.Encoding.UTF8.GetBytes
        |> this.PostMessage (queue)
    member this.RPCCall (queueName: string) (headers: System.Collections.Generic.IDictionary<string, obj>) (message: byte[]) =
        let props = channel.CreateBasicProperties()
        let correlationId = System.Guid.NewGuid().ToString()
        props.Headers <- headers
        props.ContentType <- "application/json"
        props.ReplyTo <- replyQueueName
        props.CorrelationId <- correlationId
        channel.BasicPublish (queueName, queueName, props, message)
        let response = replyLoop consumer correlationId
        response.Body
    member this.RPCJsonCall (queue: string) (message: 'a) (headers: System.Collections.Generic.IDictionary<string, obj>)  =
        message
        |> <%= name %>AMQPChannel.serializeJson
        |> System.Text.Encoding.UTF8.GetBytes
        |> this.RPCCall queue headers
        |> System.Text.Encoding.UTF8.GetString
    interface System.IDisposable with
        member this.Dispose () =
            channel.Dispose()
            ()

type private <%= name %>AMQPEndpoint(uri) = //"amqp://guest:guest@localhost/"
    let factory = new ConnectionFactory(Uri = uri)
    let connection = factory.CreateConnection()
    member this.GetChannel () =
        let channel = connection.CreateModel()
        new <%= name %>AMQPChannel(channel)
    interface System.IDisposable with
        member this.Dispose () =
            connection.Dispose()
            ()

type <%= name %>(connectionString: string, queueName: string) =
    let amqpEndpoint = new <%= name %>AMQPEndpoint ( connectionString )
    let amqpEndpointChannel = amqpEndpoint.GetChannel()
<% include ../arraySplit %>
    <% for(var op in operations) {
    var $inMessage = operations[op].inMessage;
    var $outMessage = operations[op].outMessage;
    var $nschemaMessage,
    $nschemaMessageDirection;
    %>/// <summary><%- operations[op].description || '' %></summary>
<% $inMessage.data.forEach(function (par) {
%>    /// <param name="<%- par.name %>"><%- par.description || '' %></param>
<% }); %>    /// <returns><%- $outMessage.data.map(function (d) { return d.description || ''; }).join(', ') %></returns>
    member this.<%= op %><% if (!$inMessage.data.length) {%> () <%} else { $inMessage.data.forEach(function (par) {
%> (<%= par.name %>: <%= $typescript.typeName(par.type, $nschema, null, null, $context) %>)<% }); } %> : (<% $nschemaMessage = $outMessage; $nschemaMessageDirection = 'out'; %><% include ../messageType %>) =
        let paramDict = dict [|("x-operationName","<%= op %>" :> obj)|]
        let msg = [<%- $inMessage.data.map(function (par) { return par.name + ' |> ' + name + 'AMQPChannel.serializeJson '; }).join(';') %>]
                  |> String.concat ","
        let outputStrList =
            "[" + msg + "]"
            |> System.Text.Encoding.UTF8.GetBytes
            |> amqpEndpointChannel.RPCCall queueName paramDict
            |> System.Text.Encoding.UTF8.GetString
            |> arraySplit
<% $outMessage.data.forEach(function (outputPar, outputParIndex) {%>
        let <%- outputPar.name %> =
            use textReader = new System.IO.StringReader (outputStrList.[<%- outputParIndex %>])
            let reader = new JsonTextReader (textReader)
            serializer.Deserialize<<%= $typescript.typeName(outputPar.type, $nschema, null, null, $context) %>>(reader)<%});%>
        (<%- $outMessage.data.map(function (d) { return d.name; }).join(', ') %>)
    <% } %>
    interface System.IDisposable with
        member this.Dispose () =
            (amqpEndpoint :> System.IDisposable).Dispose ()
            (amqpEndpointChannel :> System.IDisposable).Dispose ()
namespace <%= namespace %>

open Newtonsoft.Json
open Newtonsoft.Json.Converters
open System.Runtime.Serialization
open RabbitMQ.Client

/// <summary><% if (typeof(description) === 'string') { %><%= description %><% } %></summary>
[<AbstractClass>]
type <%= name %>Consumer(connectionString: string, queueName: string) =
<% include ../arraySplit %>
    member this._connectionFactory = new RabbitMQ.Client.ConnectionFactory (Uri = connectionString)
    member this._connection = this._connectionFactory.CreateConnection ()
    member this._channel = this._connection.CreateModel ()
    member this._disposables : System.IDisposable list = [this._channel :> System.IDisposable;this._connection :> System.IDisposable]
    member this._queueName = queueName
    member this._Listen() =
        let messageHandler body (props: IBasicProperties) deliveryTag =
            let connectionFactory = this._connectionFactory
            try
                let parameters =
                    body
                    |> System.Text.Encoding.UTF8.GetString
                    |> arraySplit
                    |> Array.ofSeq
                let response =
                    match props.Headers.["x-operationName"] :?> byte array |> System.Text.Encoding.UTF8.GetString with
    <% for(var op in operations) {
        var $inMessage = operations[op].inMessage;
        var $outMessage = operations[op].outMessage;
        var $nschemaMessage,
        $nschemaMessageDirection,
        $paramCount = 0,
        $currentParam,
        $paramsString,
        $paramsList;
    %>                  | "<%= op %>" ->
    <% $inMessage.data.forEach(function (p) {
       $paramCount += 1; $currentParam = 'parameter' + $paramCount; %>
                        let <%= $currentParam %> =
                            use textReader = new System.IO.StringReader (parameters.[<%= $paramCount - 1 %>])
                            let reader = new JsonTextReader (textReader)
                            serializer.Deserialize<<%= $typescript.typeName(p.type, $nschema, null, null, $context) %>>(reader)
    <% }); %>
                        let <%
                                $paramCount = 0;
                                $paramsString =
                                        $outMessage.data.map(function (p) { $paramCount += 1; $currentParam = 'response' + $paramCount; return $currentParam; }).join(',');
        $paramsString = $paramsString || '_';
    %><%= $paramsString %> = (this.<%= op %> <% $paramCount = 0; $paramsString = $inMessage.data.map(function (p) { $paramCount += 1; $currentParam = 'parameter' + $paramCount; return ' ( ' + $currentParam + ' ) '; }).join(' '); %><%= $paramsString %> )
                        let value =<% $paramsList = []; $paramCount = 0; $paramsString = $outMessage.data.forEach(function (p) { $paramCount += 1; $currentParam = 'response' + $paramCount; $paramsList.push($currentParam);%>
                            let <%= $currentParam %>Str = <%= $currentParam %> |> JsonConvert.SerializeObject<%}); %>
                            [<%= $paramsList.map(function (i) { return i + 'Str'; }).join(';')%>]
                            |> String.concat ","
                        "[" + value + "]"

    <% } %>
                      | opName ->
                            use connection = connectionFactory.CreateConnection ()
                            use channel = connection.CreateModel ()
                            channel.BasicReject(deliveryTag, false)
                            connection.Close ()
                            failwith "Unsupported operation: " + opName
                let responseBytes = System.Text.Encoding.UTF8.GetBytes(response)
                use connection = this._connectionFactory.CreateConnection ()
                use channel = connection.CreateModel ()
                let replyProps = channel.CreateBasicProperties ()
                replyProps.CorrelationId <- props.CorrelationId
                channel.BasicPublish ("", props.ReplyTo, replyProps, responseBytes)
                channel.BasicAck(deliveryTag, false)
                connection.Close ()
            with
                | e ->
                    use connection = connectionFactory.CreateConnection ()
                    use channel = connection.CreateModel ()
                    channel.BasicReject(deliveryTag, true)
                    connection.Close()

        let rec consumeLoop (consumer: RabbitMQ.Client.QueueingBasicConsumer) queueName callback =
            try
                let eventArgs = consumer.Queue.Dequeue()
                async {
                    callback eventArgs.Body eventArgs.BasicProperties eventArgs.DeliveryTag
                }
                |> Async.Start
                // Crear un task o un thread whatever
                consumeLoop consumer queueName callback
            with
                | :? System.IO.EndOfStreamException ->
                    ()
                | e ->
                    raise e
        let startConsume (channel) (queueName) (callback) =
            let consumer = new RabbitMQ.Client.QueueingBasicConsumer (channel)
            channel.BasicConsume (queueName, true, consumer) |> ignore
            consumeLoop consumer queueName callback

        do
            this._channel.ExchangeDeclare (queueName, ExchangeType.Headers, true)
            this._channel.QueueDeclare (queueName, true, false, false, null) |> ignore
            this._channel.QueueBind (queueName, queueName, System.String.Empty, null)
            this._channel.BasicQos (0u, uint16(1), false)
            startConsume this._channel queueName messageHandler

<% for(var op in operations) {
var $inMessage = operations[op].inMessage;
var $outMessage = operations[op].outMessage;
var $nschemaMessage,
    $nschemaMessageDirection;
%>    /// <summary><%- operations[op].description || '' %></summary>
<% $inMessage.data.forEach(function (par) {
%>    /// <param name="<%- par.name %>"><%- par.description || '' %></param>
<% }); %>    /// <returns><%- $outMessage.data.map(function (d) { return d.description || ''; }).join(', ') %></returns>
    abstract member <%= op %>: <% $nschemaMessage = $inMessage; $nschemaMessageDirection = 'in'; %><% include ../messageType %> -> (<% $nschemaMessage = $outMessage; $nschemaMessageDirection = 'out'; %><% include ../messageType %>)
<% } %>
    abstract member Dispose: unit -> unit
    default this.Dispose () =
        this._disposables
        |> Seq.iter (fun d -> d.Dispose () )

    interface System.IDisposable with
        member this.Dispose () = this.Dispose ()